#include <DHT.h>
#include <ESP32Servo.h>
#include <math.h>
#include <WiFi.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include <time.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

//==================== CẤU HÌNH KẾT NỐI WIFI + API ====================
// TODO: NHẬP THÔNG TIN CỦA BẠN TRƯỚC KHI UPLOAD
const char* WIFI_SSID = "phmiinh";
const char* WIFI_PASS = "23061972";

// Đặt địa chỉ server là IP của máy chạy Next.js (KHÔNG dùng localhost)
// Ví dụ: "http://192.168.1.100:3000"
const char* SERVER_BASE = "http://192.168.1.148:3000";

// Thông tin xác thực thiết bị (xem trong Prisma Studio hoặc khi seed)
const char* DEVICE_ID = "esp32-001";
const char* DEVICE_API_KEY = "3e1fd16c1c479a7b2a3dd2f45881ebaea29a75853e160f9cda5d5fa0f428e92e";

// Chu kỳ gửi status và poll command
const unsigned long STATUS_INTERVAL_MS = 30000; // 30s
const unsigned long POLL_INTERVAL_MS   = 3000;  // 3s - phản hồi web nhanh hơn

unsigned long lastStatusMs = 0;
unsigned long lastPollMs   = 0;

// WiFi status tracking for logging
int prevWifiStatus = -1;

// DHT cache to avoid blocking and NaN propagation
unsigned long lastDhtMs = 0;
float cachedHumidity = NAN;
float cachedTemperature = NAN;

// WiFi reconnect ticker
unsigned long lastWifiAttemptMs = 0;
// WiFi heartbeat for dev logs
unsigned long lastWifiHeartbeatMs = 0;
int wifiReconnectCount = 0;
const unsigned long WIFI_HEARTBEAT_MS_CONNECTED = 5000;
const unsigned long WIFI_HEARTBEAT_MS_DISCONNECTED = 1000;
// Async WiFi scan
unsigned long lastWifiScanReqMs = 0;
bool wifiScanRequested = false;
int lastKnownChannel = 0;

//==================== CẤU HÌNH CHÂN PHẦN CỨNG ====================
// DHT22
#define DHT_PIN   4
#define DHT_TYPE  DHT22

// HC-SR04
#define TRIG_PIN  5
#define ECHO_PIN  18

// Servo SG90
#define SERVO_PIN 25

// CÔNG TẮC GẠT (Slide Switch)
// Nối chân giữa vào Pin, chân cạnh vào GND.
// Khi gạt sang GND -> Pin đọc LOW -> Kích hoạt.
#define SW_OPEN_PIN   26   // Công tắc Mở cửa
#define SW_CLOSE_PIN  27   // Công tắc Đóng cửa

// LED cảnh báo (qua điện trở 220Ω)
#define LED_PIN        2    // led1 -> r1 -> D2

//==================== CẤU HÌNH SERVO ====================

// Định nghĩa 4 mức góc mở
const int ANGLE_OPEN_FULL = 0;    // Mở hết (Nước cao)
const int ANGLE_OPEN_MID  = 30;   // Mở vừa
const int ANGLE_CLOSE_MID = 60;   // Khép hờ
const int ANGLE_CLOSE_FULL= 90;   // Đóng chặt (Nước thấp/An toàn)
const int max_distance = 404;
const int time_range = 5;

int currentAngle = ANGLE_CLOSE_FULL;
int targetAngle  = ANGLE_CLOSE_FULL;

Servo gateServo;  // dùng thư viện ESP32Servo

//==================== BIẾN LƯU TRỮ LỊCH SỬ (CHO BACKUP PLAN) ====================
unsigned long lastHistoryTime = 0;
const unsigned long HISTORY_INTERVAL = time_range * 60 * 1000; // Đổi ra ms
float historyTemp = 0.0;
float historyHum  = 0.0;
bool isFirstRun = true; // Cờ đánh dấu lần chạy đầu tiên

//==================== CẤU HÌNH MỰC NƯỚC & NGƯỠNG ML ====================

const float LEVEL_HIGH_CM_BASE = 20.0f;  // <= 20cm -> nước cao -> mở cửa
const float LEVEL_LOW_CM_BASE  = 40.0f;  // >= 40cm -> nước thấp -> đóng cửa

// Ngưỡng xác suất mưa lớn (output của mô hình ML)
const float P_HEAVY_RAIN_WARN = 0.6f;  // cảnh báo
const float P_HEAVY_RAIN_HIGH = 0.8f;  // nguy cơ rất cao

//==================== ĐỐI TƯỢNG SENSOR ====================

DHT dht(DHT_PIN, DHT_TYPE);

//==================== ML: LOGISTIC REGRESSION DỰ BÁO MƯA ====================

float predictHeavyRainNext24h(float temp_c, float humidity_pct) {
  const float BIAS   = -18.49602386139671f;
  const float W_TEMP = 0.235201f;
  const float W_HUM  = 0.151022f;

  float z = BIAS
          + W_TEMP * temp_c
          + W_HUM  * humidity_pct;

  float p = 1.0f / (1.0f + expf(-z));   // sigmoid
  return p;                             // 0..1
}

//==================== HÀM PHỤ TRỢ ====================

// Khởi tạo servo
void setupServo() {
  gateServo.setPeriodHertz(50);
  gateServo.attach(SERVO_PIN, 500, 2400); // min/max us
  gateServo.write(currentAngle);
}

// Ghi góc vào servo
void writeServoAngle(int angle) {
  angle = constrain(angle, 0, 180);
  gateServo.write(angle);
}

// Cập nhật servo: đi thẳng tới góc đích để phản hồi tức thì
void updateServo() {
  if (currentAngle != targetAngle) {
    currentAngle = targetAngle;
    writeServoAngle(currentAngle);
  }
}

// Đo khoảng cách (cm) bằng HC-SR04
float readDistanceCm() {
  digitalWrite(TRIG_PIN, LOW);
  delayMicroseconds(2);
  digitalWrite(TRIG_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);

  long duration = pulseIn(ECHO_PIN, HIGH, 25000); // 25ms timeout để tránh treo lâu
  if (duration == 0) return 9999.0f; // lỗi đo

  float distance = duration * 0.0343f / 2.0f; // cm
  return distance;
}

//==================== BIẾN TRẠNG THÁI ====================

bool manualOverride = false;   // true: điều khiển bằng Switch, false: auto

//==================== WIFI + HTTP HELPERS ====================

String isoTimestampUTC() {
  time_t now = time(nullptr);
  struct tm* tm_info = gmtime(&now);
  char buf[30];
  strftime(buf, sizeof(buf), "%Y-%m-%dT%H:%M:%SZ", tm_info);
  return String(buf);
}

// Helper: WiFi status text for logs
const char* wifiStatusText(int ws) {
  switch (ws) {
    case WL_IDLE_STATUS:     return "IDLE";
    case WL_NO_SSID_AVAIL:   return "NO_SSID";
    case WL_SCAN_COMPLETED:  return "SCAN_DONE";
    case WL_CONNECTED:       return "CONNECTED";
    case WL_CONNECT_FAILED:  return "CONNECT_FAILED";
    case WL_CONNECTION_LOST: return "CONNECTION_LOST";
    case WL_DISCONNECTED:    return "DISCONNECTED";
    default:                 return "UNKNOWN";
  }
}

String computeDoorState() {
  if (currentAngle <= 5) return "OPEN (100%)";
  if (currentAngle <= 35) return "OPEN (30 deg)";
  if (currentAngle <= 65) return "CLOSE (60 deg)";
  return "CLOSE (100%)";
}

void sendStatusToServer(float waterLevelCm, float temperature, float humidity, float pHeavyRain, const char* modeStr) {
  if (WiFi.status() != WL_CONNECTED) return;

  HTTPClient http;
  http.setTimeout(800); // giới hạn block tối đa 800ms để không làm trễ servo
  String url = String(SERVER_BASE) + "/api/status";
  http.begin(url);
  http.addHeader("Content-Type", "application/json");
  http.addHeader("x-device-id", DEVICE_ID);
  http.addHeader("x-api-key", DEVICE_API_KEY);

  StaticJsonDocument<512> doc;
  doc["deviceId"] = DEVICE_ID;
  doc["waterLevelCm"] = waterLevelCm;
  doc["doorState"] = computeDoorState();
  doc["mode"] = modeStr;
  doc["pHeavyRainNext24h"] = pHeavyRain;
  doc["temperatureC"] = temperature;
  doc["humidityPct"] = humidity;
  doc["timestamp"] = isoTimestampUTC();

  String payload;
  serializeJson(doc, payload);

  unsigned long t0 = millis();
  int code = http.POST(payload);
  unsigned long dt = millis() - t0;
  Serial.print("[HTTP] POST /api/status -> "); Serial.print(code); Serial.print(" in "); Serial.print(dt); Serial.println("ms");
  if (code > 0) {
    String resp = http.getString();
    Serial.println(resp);
  }
  http.end();
}

String pollLatestCommand() {
  if (WiFi.status() != WL_CONNECTED) return String("AUTO");

  HTTPClient http;
  http.setTimeout(500); // giới hạn tối đa 500ms để không làm trễ servo
  String url = String(SERVER_BASE) + "/api/control/latest?deviceId=" + DEVICE_ID;
  http.begin(url);
  http.addHeader("x-device-id", DEVICE_ID);
  http.addHeader("x-api-key", DEVICE_API_KEY);

  unsigned long t0 = millis();
  int code = http.GET();
  unsigned long dt = millis() - t0;
  Serial.print("[HTTP] GET /api/control/latest -> "); Serial.print(code); Serial.print(" in "); Serial.print(dt); Serial.println("ms");
  String cmd = "AUTO";
  if (code == 200) {
    String resp = http.getString();
    StaticJsonDocument<256> doc;
    DeserializationError err = deserializeJson(doc, resp);
    if (!err) {
      cmd = doc["command"].as<String>();
    }
  }
  http.end();
  return cmd;
}

void connectWifi() {
  if (strlen(WIFI_SSID) == 0) {
    Serial.println("[WiFi] Vui lòng cấu hình WIFI_SSID/WIFI_PASS trong mã!");
    return;
  }
  Serial.println("[WiFi] Initializing WiFi connection (non-blocking)...");
  WiFi.mode(WIFI_STA);
  WiFi.persistent(false);           // không ghi NVS tránh chậm
  WiFi.setSleep(false);             // tắt power-save để ổn định kết nối
  WiFi.setAutoReconnect(true);      // tự reconnect
  WiFi.setHostname(DEVICE_ID);
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  Serial.print("[WiFi] Connecting to "); Serial.println(WIFI_SSID);
  // Không chờ ở đây để tránh block servo; việc kiểm tra trạng thái sẽ thực hiện trong loop()
}

//==================== HÀM BACKUP PLAN ====================

float getTempCritical(int min) {
  if (min <= 3) return 0.95;
  if (min <= 5) return 1.50; 
  if (min <= 10) return 2.50;
  return 3.00;
}

float getHumCritical(int min) {
  if (min <= 3) return 3.2;
  if (min <= 5) return 5.0;  
  if (min <= 10) return 8.0;
  return 10.0;
}

float getTempWarning(int min) {
  if (min <= 3) return 0.6;
  if (min <= 5) return 0.8; 
  if (min <= 10) return 1.5;
  return 2.0;
}

float getHumWarning(int min) {
  if (min <= 3) return 2.0;
  if (min <= 5) return 3.0;
  if (min <= 10) return 5.0;
  return 6.0;
}

void gui_canh_bao(){
    Serial.println(">> CANH BAO KHAN CAP: DIEU KIEN BAT THUONG <<");
}

void  backup_plan(float last_hum,float now_hum,float last_temp,float now_temp){
    float lim_hum=getHumCritical(time_range),
    warn_hum=getHumWarning(time_range),
    lim_temp=getTempCritical(time_range),
    warn_temp=getTempWarning(time_range);

    Serial.print("Delta Hum: "); Serial.print(now_hum - last_hum);
    Serial.print(" Delta Temp: "); Serial.println(last_temp - now_temp);

    if(last_hum >= 98){
        targetAngle = ANGLE_OPEN_FULL;
    }
    else if(now_hum - last_hum >= lim_hum && last_temp - now_temp >= lim_temp){
        targetAngle = ANGLE_OPEN_FULL;
    }
    else if(now_hum - last_hum >= warn_hum && last_temp - now_temp >= warn_temp) {
        gui_canh_bao();
    }
    else if(last_hum >= 90){
        gui_canh_bao();
    }
}

//==================== SETUP ====================

void setup() {
  Serial.begin(115200);

  dht.begin();

  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);

  // Cấu hình chân công tắc là INPUT_PULLUP
  // Khi công tắc mở (OFF) -> Chân High
  // Khi công tắc đóng (ON - gạt sang GND) -> Chân Low
  pinMode(SW_OPEN_PIN, INPUT_PULLUP);
  pinMode(SW_CLOSE_PIN, INPUT_PULLUP);

  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, LOW);

  setupServo();

  Serial.println("Flood Barrier ESP32 + ML HeavyRainRisk (next 24h) - Starting...");

  // Kết nối WiFi (để gửi dữ liệu lên Web App)
  connectWifi();
  // Heartbeat ngay sau setup để chắc chắn có log WiFi
  Serial.print("[WiFi] Setup status="); Serial.println(wifiStatusText(WiFi.status()));
  if (WiFi.status() == WL_CONNECTED) {
    Serial.print("[WiFi] IP: "); Serial.println(WiFi.localIP());
    Serial.print("[WiFi] RSSI: "); Serial.println(WiFi.RSSI());
  }
}

//==================== LOOP ====================

void loop() {
  // 0) WiFi monitor & reconnect (non-blocking)
  unsigned long nowMs = millis();
  int ws = WiFi.status();
  if (ws != prevWifiStatus) {
    Serial.print("[WiFi] Status changed: ");
    if (ws == WL_CONNECTED) Serial.println("CONNECTED");
    else if (ws == WL_DISCONNECTED) Serial.println("DISCONNECTED");
    else if (ws == WL_IDLE_STATUS) Serial.println("IDLE");
    else if (ws == WL_CONNECT_FAILED) Serial.println("CONNECT_FAILED");
    else if (ws == WL_NO_SSID_AVAIL) Serial.println("NO_SSID");
    else if (ws == WL_CONNECTION_LOST) Serial.println("CONNECTION_LOST");
    else { Serial.print("CODE="); Serial.println(ws); }

    if (ws == WL_CONNECTED) {
      Serial.print("[WiFi] IP: "); Serial.println(WiFi.localIP());
      Serial.print("[WiFi] RSSI: "); Serial.println(WiFi.RSSI());
      configTime(0, 0, "pool.ntp.org", "time.nist.gov");
    } else {
      // trigger a fast async scan right on status change
      int s = WiFi.scanComplete();
      if (s == WIFI_SCAN_FAILED || s == -2) {
        Serial.println("[WiFi] Scan start (status-changed)...");
        WiFi.scanNetworks(true);
        wifiScanRequested = true;
        lastWifiScanReqMs = nowMs;
      }
    }
    prevWifiStatus = ws;
  }
  if (ws != WL_CONNECTED && nowMs - lastWifiAttemptMs >= 5000) {
    Serial.print("[WiFi] Reconnecting");
    if (lastKnownChannel > 0) { Serial.print(" on ch="); Serial.print(lastKnownChannel); }
    Serial.println("...");
    WiFi.disconnect(true);
    if (lastKnownChannel > 0) {
      WiFi.begin(WIFI_SSID, WIFI_PASS, lastKnownChannel);
    } else {
      WiFi.begin(WIFI_SSID, WIFI_PASS);
    }
    wifiReconnectCount++;
    lastWifiAttemptMs = nowMs;
  }

  // WiFi heartbeat log for developer visibility
  if (lastWifiHeartbeatMs == 0 || nowMs - lastWifiHeartbeatMs >= 5000) {
    Serial.print("[WiFi] Heartbeat: status="); Serial.print(wifiStatusText(ws));
    if (ws == WL_CONNECTED) {
      Serial.print(" IP="); Serial.print(WiFi.localIP());
      Serial.print(" RSSI="); Serial.print(WiFi.RSSI());
      Serial.print(" Ch="); Serial.print(WiFi.channel());
    }
    Serial.print(" reconnects="); Serial.println(wifiReconnectCount);
    lastWifiHeartbeatMs = nowMs;
  }

  // If disconnected, run async scan every 10s and print top results
  if (ws != WL_CONNECTED) {
    int scanState = WiFi.scanComplete();
    if (scanState == WIFI_SCAN_FAILED || scanState == -2) {
      // not running
      if (!wifiScanRequested && nowMs - lastWifiScanReqMs >= 10000) {
        Serial.println("[WiFi] Scan start...");
        WiFi.scanNetworks(true /*async*/);
        wifiScanRequested = true;
        lastWifiScanReqMs = nowMs;
      }
    } else if (scanState >= 0) {
      int n = scanState;
      Serial.print("[WiFi] Scan done: "); Serial.print(n); Serial.println(" APs");
      int foundIdx = -1;
      int show = n > 6 ? 6 : n;
      for (int i = 0; i < show; i++) {
        String ssid = WiFi.SSID(i);
        int32_t rssi = WiFi.RSSI(i);
        int32_t ch   = WiFi.channel(i);
        wifi_auth_mode_t enc = (wifi_auth_mode_t)WiFi.encryptionType(i);
        Serial.print("  "); Serial.print(i); Serial.print(": "); Serial.print(ssid);
        Serial.print(" RSSI="); Serial.print(rssi);
        Serial.print(" Ch="); Serial.print(ch);
        Serial.print(" Enc="); Serial.println((int)enc);
        if (ssid == WIFI_SSID && foundIdx == -1) { foundIdx = i; lastKnownChannel = ch; }
      }
      if (foundIdx >= 0) {
        Serial.print("[WiFi] Target SSID found on ch="); Serial.print(lastKnownChannel); Serial.println(" (will use on next reconnect)");
      } else {
        Serial.println("[WiFi] Target SSID NOT FOUND");
      }
      WiFi.scanDelete();
      wifiScanRequested = false;
    }
  }

  // 1) Đọc cảm biến
  float humidity    = dht.readHumidity();
  float temperature = dht.readTemperature();
  float distance    = readDistanceCm();
  //distance=900; //test backup
  
  if (isnan(humidity) || isnan(temperature)) {
    Serial.println("Loi DHT22 (NaN) – bo qua chu ky nay");
    delay(50); // tránh block lâu làm trễ servo
    return;
  }

  // --- QUẢN LÝ LỊCH SỬ ---
  if (isFirstRun || (millis() - lastHistoryTime >= HISTORY_INTERVAL)) {
      historyTemp = temperature;
      historyHum  = humidity;
      lastHistoryTime = millis();
      isFirstRun = false;
      Serial.println(">>> [HISTORY UPDATED] Da luu thong so moi.");
  }

  // 2) Tính xác suất mưa
  float pHeavyRainNext24h = predictHeavyRainNext24h(temperature, humidity);

  // 3) Điều chỉnh ngưỡng mực nước
  float levelHigh = LEVEL_HIGH_CM_BASE;
  float levelLow  = LEVEL_LOW_CM_BASE;

  if (pHeavyRainNext24h >= P_HEAVY_RAIN_HIGH) {
    levelHigh = LEVEL_HIGH_CM_BASE + 10.0f;
    levelLow  = LEVEL_LOW_CM_BASE  + 20.0f;
  } else if (pHeavyRainNext24h >= P_HEAVY_RAIN_WARN) {
    levelHigh = LEVEL_HIGH_CM_BASE + 5.0f;
    levelLow  = LEVEL_LOW_CM_BASE  + 10.0f;
  }

  // ==================== 4) XỬ LÝ CÔNG TẮC GẠT (Slide Switch) ====================
  // Logic: INPUT_PULLUP -> Gạt sang GND đọc là LOW (Active)
  bool swOpenActive  = (digitalRead(SW_OPEN_PIN)  == LOW);
  bool swCloseActive = (digitalRead(SW_CLOSE_PIN) == LOW);

  if (swOpenActive && !swCloseActive) {
    // Chỉ gạt công tắc Mở -> Manual Mở
    manualOverride = true;
    targetAngle = ANGLE_OPEN_FULL;
  } 
  else if (!swOpenActive && swCloseActive) {
    // Chỉ gạt công tắc Đóng -> Manual Đóng
    manualOverride = true;
    targetAngle = ANGLE_CLOSE_FULL;
  } 
  else {
    // Nếu cả 2 công tắc đều TẮT (hoặc user gạt cả 2 cái ON - vô lý),
    // Hệ thống trả về chế độ AUTO
    manualOverride = false;
  }

  // 5) Chế độ TỰ ĐỘNG (Chỉ chạy khi công tắc đều OFF)
  if (!manualOverride) {
    if(distance > max_distance){
        // Cảm biến siêu âm lỗi hoặc quá xa -> Dùng Backup Plan theo nhiệt/ẩm
        backup_plan(historyHum, humidity, historyTemp, temperature);
    }
    else if (distance <= levelHigh) {
      targetAngle = ANGLE_OPEN_FULL;
    } else if (distance >= levelLow) {
      targetAngle = ANGLE_CLOSE_FULL;
    } else {
      // Phân chia khoảng giữa để có 4 mức góc: 0 / 30 / 60 / 90
      float midPoint = (levelHigh + levelLow) / 2.0f;
      if (distance < midPoint) targetAngle = ANGLE_OPEN_MID;   // ~30°
      else                     targetAngle = ANGLE_CLOSE_MID;  // ~60°
    }
  }

  // Log khi đổi targetAngle để xác nhận phản hồi tức thì
  static int lastTargetAngleLog = -999;
  if (targetAngle != lastTargetAngleLog) {
    Serial.print("[Servo] targetAngle -> "); Serial.print(targetAngle);
    Serial.print(" (from "); Serial.print(lastTargetAngleLog); Serial.print(") at "); Serial.print(millis()); Serial.println("ms");
    lastTargetAngleLog = targetAngle;
  }

  // 6) Cập nhật servo & LED
  updateServo();

  if (pHeavyRainNext24h >= P_HEAVY_RAIN_WARN) digitalWrite(LED_PIN, HIGH);
  else                                        digitalWrite(LED_PIN, LOW);

  // 7) Log debug
  Serial.print("Dist=");Serial.print(distance);    Serial.print("cm  ");
  Serial.print("RainRisk="); Serial.print(pHeavyRainNext24h, 2);
  Serial.print(" | Mode: ");
  Serial.print(manualOverride ? "MANUAL (Switch)" : "AUTO");
  Serial.print(" | Switch: [Open:"); Serial.print(swOpenActive);
  Serial.print(" Close:"); Serial.print(swCloseActive); Serial.println("]");

  // 8) GỬI DỮ LIỆU LÊN WEB APP + POLL COMMAND
  unsigned long now = millis();
  if (now - lastStatusMs >= STATUS_INTERVAL_MS) {
    const char* modeStr = manualOverride ? "MANUAL" : "AUTO";
    sendStatusToServer(distance, temperature, humidity, pHeavyRainNext24h, modeStr);
    lastStatusMs = now;
  }

  if (now - lastPollMs >= POLL_INTERVAL_MS) {
    String cmd = pollLatestCommand();
    if (cmd == "OPEN") {
      manualOverride = true;  // ép mở theo lệnh Web
      targetAngle = ANGLE_OPEN_FULL;
    } else if (cmd == "CLOSE") {
      manualOverride = true;  // ép đóng theo lệnh Web
      targetAngle = ANGLE_CLOSE_FULL;
    } else if (cmd == "AUTO") {
      // trả về AUTO; trạng thái manualOverride sẽ được quyết bởi công tắc
      // nếu người dùng muốn giữ manual bằng công tắc, không thay đổi cờ tại đây
    }
    lastPollMs = now;
  }

  delay(20);  // 50Hz update rate - nhanh và mượt hơn 
}
